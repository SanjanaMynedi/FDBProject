# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s_MwLeOPDsqWZf83yvUMyic-lJ2CToRH
"""

import os

DB_FILE = "data.db"
ORDER = 4  # Maximum number of keys in a node (for simplicity)

# ----------------- B+ Tree Implementation -----------------
class BPlusTreeNode:
    def __init__(self, leaf=False):
        self.leaf = leaf
        self.keys = []
        self.children = []  # children nodes or values if leaf
class KeyNotFoundError(Exception):
    """Custom exception for key not found in B+ Tree."""
    pass
class BPlusTree:
    def __init__(self):
        self.root = BPlusTreeNode(leaf=True)

    def search(self, key):
        node = self.root
        while not node.leaf:
            i = 0
            while i < len(node.keys) and key >= node.keys[i]:
                i += 1
            node = node.children[i]
        # Linear search in leaf
        for i, k in enumerate(node.keys):
            if k == key:
                return node.children[i]
        raise KeyNotFoundError(f"Key '{key}' not found in B+ Tree")

    def insert(self, key, value):
        root = self.root
        if len(root.keys) == ORDER - 1:
            new_root = BPlusTreeNode()
            new_root.children.append(self.root)
            self._split_child(new_root, 0)
            self.root = new_root
        self._insert_non_full(self.root, key, value)

    def _insert_non_full(self, node, key, value):
        if node.leaf:
            # Overwrite if exists
            for i, k in enumerate(node.keys):
                if k == key:
                    node.children[i] = value
                    return
            # Insert new
            i = 0
            while i < len(node.keys) and node.keys[i] < key:
                i += 1
            node.keys.insert(i, key)
            node.children.insert(i, value)
        else:
            i = 0
            while i < len(node.keys) and key >= node.keys[i]:
                i += 1
            child = node.children[i]
            if len(child.keys) == ORDER - 1:
                self._split_child(node, i)
                if key >= node.keys[i]:
                    i += 1
            self._insert_non_full(node.children[i], key, value)

    def _split_child(self, parent, index):
        node = parent.children[index]
        mid = len(node.keys) // 2
        if node.leaf:
            new_node = BPlusTreeNode(leaf=True)
            new_node.keys = node.keys[mid:]
            new_node.children = node.children[mid:]
            node.keys = node.keys[:mid]
            node.children = node.children[:mid]
            parent.keys.insert(index, new_node.keys[0])
            parent.children.insert(index + 1, new_node)
        else:
            new_node = BPlusTreeNode(leaf=False)
            new_node.keys = node.keys[mid+1:]
            new_node.children = node.children[mid+1:]
            parent.keys.insert(index, node.keys[mid])
            parent.children.insert(index + 1, new_node)
            node.keys = node.keys[:mid]
            node.children = node.children[:mid+1]

# ----------------- Key-Value Store -----------------
class KVStore:
    def __init__(self):
        self.tree = BPlusTree()
        self.load_data()

    def load_data(self):
        if not os.path.exists(DB_FILE):
            return
        with open(DB_FILE, 'r') as f:
            for line in f:
                parts = line.strip().split(' ', 2)
                if len(parts) == 3 and parts[0] == 'SET':
                    key, value = parts[1], parts[2]
                    self.tree.insert(key, value)

    def set(self, key, value):
        with open(DB_FILE, 'a') as f:
            f.write(f"SET {key} {value}\n")
        self.tree.insert(key, value)

    def get(self, key):
        return self.tree.search(key)

# ----------------- CLI -----------------
def main():
    kv = KVStore()
    while True:
        try:
            command = input().strip()
        except EOFError:
            break
        if not command:
            continue
        parts = command.split(' ', 2)
        cmd = parts[0].upper()
        if cmd == 'EXIT':
            break
        elif cmd == 'SET' and len(parts) == 3:
            kv.set(parts[1], parts[2])
        elif cmd == 'GET' and len(parts) == 2:
            print(kv.get(parts[1]))
        else:
            print("ERROR: Invalid command")

if __name__ == "__main__":
    main()